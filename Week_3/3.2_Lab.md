# Week 3.2 Lab: Operations Monitoring Fundamentals

## Lab Overview
Learn the operations side of DevOps - monitoring systems, services, and infrastructure like professional SRE (Site Reliability Engineering) teams do.

**Environment:** Raspberry Pi 4 (preferred) or GitHub Codespaces  
**Focus:** Real-world ops monitoring tools and practices

---

## Learning Objectives
By the end of this lab, you will be able to:
- Monitor system resources (CPU, memory, disk) like ops teams do
- Check service health and availability
- Analyse system logs for troubleshooting
- Understand what data feeds into monitoring dashboards
- Use professional Linux monitoring tools

---

## Part 1: System Resource Monitoring

### Step 1.1: Real-Time System Monitor

**Install htop (if needed):**
```bash
# Check if available
which htop || sudo apt update && sudo apt install htop -y

# Launch interactive monitor
htop
```

**What you're seeing:**
- **Top section:** CPU usage, memory, swap
- **Middle:** Process list (what's running)
- **Bottom:** Available commands

**Record your system metrics:**

| Metric | Value | What it means |
|--------|-------|---------------|
| CPU usage | _____% | How busy your processor is |
| Memory used | _____ MB / _____ MB | RAM consumption |
| Load average | _____ | System workload (1min avg) |
| Running processes | _____ | Total active programs |

**Press Q to quit htop**

### Step 1.2: Quick System Checks

**CPU information:**
```bash
# How many CPU cores?
nproc

# Current CPU usage
top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - $1"%"}'
```

**Memory check:**
```bash
# Memory in human-readable format
free -h
```

**Disk space:**
```bash
# Check available storage
df -h /
```

**Your system health snapshot:**
- CPU cores: _____
- Current CPU usage: _____% 
- Available memory: _____ GB
- Free disk space: _____ GB
- Overall health: ⬜ Good ⬜ Warning ⬜ Critical

**Ops Question:** At what percentage should you get alerts? *(Hint: Most ops teams alert at 80% usage)*

---

## Part 2: Service Monitoring

### Step 2.1: Understanding Service Management

**⚠️ Important Environment Difference:**

**On Raspberry Pi:** Use `systemctl` commands
```bash
# List all running services (Raspberry Pi)
systemctl list-units --type=service --state=running
```

**On GitHub Codespaces:** Use `service` commands instead
```bash
# Check service status (Codespaces)
service --status-all
```

**Why the difference?** Codespaces uses a lightweight container environment that doesn't run `systemd` (the system and service manager) due to overhead. The `service` command provides similar functionality in this environment.

**For the rest of this lab:**
- **Raspberry Pi students:** Use `systemctl` commands as shown
- **Codespaces students:** Use `service` commands as the alternative

### Step 2.2: List Running Services

**Raspberry Pi:**
```bash
systemctl list-units --type=service --state=running
```

**Codespaces:**
```bash
service --status-all
```

**Understanding the output:**

**Raspberry Pi output shows:**
- Service name
- Load state (loaded/not loaded)
- Active state (active/inactive)
- Description

**Codespaces output shows:**
- `[ + ]` = service is running
- `[ - ]` = service is stopped
- `[ ? ]` = status unknown

**Count your services:**
- Total running services: _____
- Critical system services you recognise: _____

### Step 2.3: Check Individual Service Status

**SSH service status:**

**Raspberry Pi:**
```bash
systemctl status ssh
```

**Codespaces:**
```bash
service ssh status
```

**What to look for:**
- **Active:** `active (running)` = healthy ✅
- **Active:** `inactive (dead)` = stopped ❌
- **Failed:** Something went wrong 🚨

**Your SSH status:**
- State: _____
- Since when: _____
- Any errors: _____

**Network service:**

**Raspberry Pi:**
```bash
systemctl status networking
```

**Codespaces:**
```bash
# Codespaces may not have a networking service
# Check what services are available instead:
service --status-all
```

**Record:** Is networking/ssh service active? _____

---

## Part 3: Log Analysis

### Step 3.1: System Logs with journalctl

**⚠️ Environment Note:** This section works best on Raspberry Pi where `systemd` is available.

**Raspberry Pi - View recent system logs:**
```bash
# Last 20 log entries
journalctl -n 20
```

**Codespaces - Alternative log viewing:**
```bash
# View system logs
sudo tail -n 20 /var/log/syslog

# Or use dmesg for kernel messages
dmesg | tail -n 20
```

**What ops teams look for:**
- Error messages (priority: err, crit, alert)
- Authentication attempts
- Service start/stop events
- Unusual activity patterns

**Filter logs by priority (Raspberry Pi):**
```bash
# Only show warnings and errors
journalctl -p warning -n 10
```

**Alternative for Codespaces:**
```bash
# Grep for errors and warnings
sudo grep -i "error\|warning" /var/log/syslog | tail -n 10
```

**Your log analysis:**
- Recent errors found: _____
- Most recent warning: _____
- Any security-relevant events: _____

### Step 3.2: Service-Specific Logs

**SSH authentication logs:**

**Raspberry Pi:**
```bash
# Check for login attempts
journalctl -u ssh -n 20 --no-pager
```

**Codespaces:**
```bash
# Check SSH logs directly
sudo grep "ssh" /var/log/auth.log | tail -n 20
```

**Look for:**
- `Accepted password` = successful login
- `Failed password` = failed attempt
- `Connection closed` = session ended

**Authentication analysis:**
- Successful logins: _____
- Failed attempts: _____
- Suspicious activity: _____

### Step 3.3: Real-Time Log Monitoring

**Watch logs in real-time (like ops teams do):**

**Raspberry Pi:**
```bash
# Follow system logs (Ctrl+C to stop)
journalctl -f
```

**Codespaces:**
```bash
# Follow syslog (Ctrl+C to stop)
sudo tail -f /var/log/syslog
```

**In another terminal, generate some activity:**

**Raspberry Pi:**
```bash
# Create log entries
logger "Test monitoring event - Week 3.2 Lab"
systemctl status networking > /dev/null
```

**Codespaces:**
```bash
# Create log entries
logger "Test monitoring event - Week 3.2 Lab"
service ssh status > /dev/null
```

**Observation:**
- Did your test message appear? _____
- How quickly did it show up? _____
- What other activity did you see? _____

**Stop the real-time monitoring (Ctrl+C)**

---

## Part 4: Network Connection Monitoring

### Step 4.1: Active Connections

**See what's connected:**
```bash
# Current network connections
ss -tunap
```

**Connection analysis:**
- Total connections: _____
- ESTABLISHED connections: _____
- Services listening: _____

### Step 4.2: Network Traffic Monitoring

**Install iftop (if needed):**
```bash
which iftop || sudo apt update && sudo apt install iftop -y
```

**Monitor network bandwidth (requires sudo):**
```bash
# Real-time network traffic
sudo iftop -i eth0 -t -s 10
```

**Note:** 
- **Raspberry Pi:** Replace `eth0` with `wlan0` for Wi-Fi, or check your interface with `ip link`
- **Codespaces:** May not work due to container restrictions - this is normal, just observe the concept

**Network metrics (if available):**
- Busiest connection: _____
- Incoming rate: _____ KB/s
- Outgoing rate: _____ KB/s

### Step 4.3: Connection Count Over Time

**Simple connection logger:**
```bash
# Log connections every 5 seconds (run for 30 seconds)
for i in {1..6}; do
    echo "$(date +%H:%M:%S): $(ss -t | grep ESTAB | wc -l) active connections"
    sleep 5
done
```

**Pattern observation:**
- Highest connection count: _____
- Lowest connection count: _____
- Average: _____
- Pattern stable or varying? _____

---

## Part 5: Building Your Ops Data Collection

### Step 5.1: What to Monitor (Ops Best Practices)

**Create monitoring checklist based on your lab:**

**System Resources:**
- [ ] CPU usage < 80%
- [ ] Memory usage < 80%
- [ ] Disk space > 20% free
- [ ] Load average reasonable

**Services:**
- [ ] Critical services running
- [ ] No failed service startups
- [ ] Service restart counts normal

**Logs:**
- [ ] No critical errors in last hour
- [ ] Authentication failures < threshold
- [ ] No unusual activity patterns

**Network:**
- [ ] Connection counts expected
- [ ] No unusual bandwidth spikes
- [ ] All ports/services accounted for

### Step 5.2: Data Collection for Dashboards

**What data would you send to a dashboard?**

**Metrics (numbers over time):**
- CPU percentage
- Memory used/free
- Disk usage
- Active connections
- Service uptime

**Events (things that happened):**
- Service restarts
- Error log entries
- Failed login attempts
- System warnings

**Status (current state):**
- Service health (up/down)
- System health (good/warning/critical)
- Alert conditions (triggered/clear)

**Your dashboard data plan:**

| Data Type | Source Command | Update Frequency | Display As |
|-----------|---------------|------------------|------------|
| CPU usage | `top -bn1` | Every 5 seconds | Line graph |
| Memory | `free -h` | Every 5 seconds | Gauge |
| Service status | `systemctl/service status` | Every 30 seconds | Status indicator |
| Log errors | `journalctl/grep logs` | Every minute | Alert count |

---

## Real-World Ops Connection

### Australian DevOps Teams Using These Tools

**Commonwealth Bank SRE Team:**
- Monitors thousands of servers using similar tools
- `systemd` for service management
- ELK stack for log aggregation (built on journalctl concepts)
- Grafana dashboards fed by Prometheus metrics

**Atlassian (Melbourne):**
- Uses system metrics for capacity planning
- Monitors service health across global infrastructure
- Real-time alerting when services fail
- Incident response based on log analysis

**Your School's IT Team (probably):**
- Monitors server resources and services
- Checks logs when students report problems
- Uses similar Linux tools for troubleshooting
- May have dashboards showing network/service health

---

## Reflection Questions

### Understanding Ops Role

1. **Data Collection:** What system data would be most critical to monitor 24/7?
   `_________________________________________________`

2. **Alert Thresholds:** At what point should ops teams get woken up at 3am?
   `_________________________________________________`

3. **Troubleshooting:** How do logs help ops teams fix problems faster?
   `_________________________________________________`

### Connecting to Dashboard Development

4. **Dashboard Design:** Based on your monitoring, what should a dashboard show first?
   `_________________________________________________`

5. **Update Frequency:** How often should dashboard data refresh? Why?
   `_________________________________________________`

6. **Visual Priority:** What metrics need graphs vs simple numbers?
   `_________________________________________________`

---

## Lab Submission

**Complete this ops monitoring summary:**

1. **System CPU usage:** _____% 
2. **Critical services monitored:** _____
3. **Log errors found:** _____
4. **Active network connections:** _____
5. **Most valuable monitoring tool:** _____
6. **Key ops skill learned:** _____

**Answer in one sentence each:**

7. **What's the difference between monitoring metrics vs monitoring logs?**

8. **Why do ops teams need real-time dashboards instead of just running commands?**

9. **What would happen if ops teams didn't monitor services continuously?**

---

## Next: Week 3.2 Code Practice - Streamlit Dashboards

**Coming up:** Build professional monitoring dashboards with Streamlit that display all the ops data you just learned to collect!

**Preview:** Your Streamlit dashboard will show:
- Real-time CPU/memory graphs (data from `htop`)
- Service status indicators (data from `systemctl/service`)
- Log error counts (data from `journalctl/logs`)
- Network connection visualisations (data from `ss`)

---

## 🔍 Real-World Connection: Professional Monitoring Tools

### What Real Companies Use

Professional DevOps teams use monitoring tools like **Netdata**, **Grafana**, or **Prometheus** in production. These are enterprise-grade dashboards that automatically collect and display system metrics.

### What You're Building

**In this code practice, you'll build your own monitoring dashboard** using Streamlit and Python.

**Why build your own instead of using existing tools?**
- **Understand how it works** - learn what's happening under the hood
- **Customise everything** - add exactly the features you want
- **Dev skills** - this is the "Dev" side of DevOps
- **Portfolio piece** - you built this yourself!

**The connection:**
- **Lab (Ops):** You learned what data to collect
- **Code (Dev):** Now build the dashboard that displays it

Professional tools like Netdata are amazing for production, but building your own teaches you the skills to create any monitoring solution you need!